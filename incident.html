<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>
         Time since last incident
      </title>
      <style>
	.notice {
	    text-align: center;
	    vertical-align: middle;
	    margin-left: auto;
	    margin-right: auto;
	    margin-bottom: 50px;
	    margin-top: auto;
	    font-size: 50pt;
	}

	.time {
	    text-align: center;
	    vertical-align: middle;
	    margin: auto;
	    font-size: 50pt;
	}

	.best-notice {
	    text-align: center;
	    vertical-align: middle;
	    margin-left: auto;
	    margin-right: auto;
	    margin-bottom: auto;
	    margin-top: 100px;
	    font-size: 20pt;
	}

	.days {
	    text-align: center;
	    vertical-align: middle;
	    margin: auto;
	    font-size: 350pt;
	    height: 500px;
	}
      </style>
   </head>
   <body id="body">
	<div id="days" class="days">00000</div>
	<div class="notice" id="days-notice">days since last incident</div>
	<div id="time" class="time">0.00:00:00</div>
	<div class="notice" id="time-notice">since last incident</div>
	<div class="best-notice">the best duration <span id="duration">&lt;none&gt;</span> achieved at <span id="achieved">&lt;never&gt;</span></div>
   </body>
   <script>
	// Zenith day threshold values:
	// * Include day time only: 90 + 50.0 / 60.0
	// * Include civil twilight: 96
	// * Include nautical twilight: 102
	// * Include astronomical twilight: 108
	const zenithDayThresholdDegrees = 90 + 50.0 / 60.0;

	// Put your city coordinates here
	const latitude = 0.0;
	const longitude = 0.0;

	// Put last incident data here
	const lastIncidentDate = new Date('1970-01-01T00:00:00Z');
	const bestPeriodBegin = new Date('1970-01-01T00:00:00Z');
	const bestPeriodEnd = new Date('1970-01-01T00:00:00Z');

	// Easter eggs
	const foolDayOn = false;
	const newYearOn = false;

	const axialTilt = 23.4392811;
	const tropicalYearMillis = 31556925190;
	const dayMillis = 86400000;
	const millisInMinute = 60000;

	function toRadians(degrees) {
	    return degrees * Math.PI / 180.0;
	}

	function toDegrees(radians) {
	    return radians * 180.0 / Math.PI;
	}

	function toSectorDegree(part) {
	    return 360.0 * part;
	}

	function isDay(date, latitude, longitude) {
	    return getCorrectedZenithInDegrees(date, latitude, longitude) < zenithDayThresholdDegrees;
	}

	function getTrueSolarMillisSinceEpoch(date) {
	    var millisSinceEpoch = date.getTime();
	    var phaseStartMillis = new Date('2019-01-01T00:00:00Z').getTime();
	    var yearPhase = toRadians(toSectorDegree(mod(millisSinceEpoch - phaseStartMillis, tropicalYearMillis) / tropicalYearMillis));
	    var equationOfTimeMillis = (-7.659 * Math.sin(yearPhase) + 9.863 * Math.sin(2 * yearPhase + 3.5932)) * millisInMinute;
	    return millisSinceEpoch + equationOfTimeMillis;
	}

	function getYearPhaseSinceNorthSummerSolstice(millisSinceEpoch) {
	    var northSummerSolsticeMillis = new Date('2019-06-21T15:54:14Z').getTime();
	    return toRadians(toSectorDegree(mod(millisSinceEpoch - northSummerSolsticeMillis, tropicalYearMillis) / tropicalYearMillis));
	}

	function getCorrectedZenithInDegrees(date, latitude, longitude) {
	    var trueSolarMillisSinceEpoch = getTrueSolarMillisSinceEpoch(date);
	    var startMillis = new Date('2019-12-26T12:00:00Z').getTime();
	    var dayPhase = toSectorDegree(mod(trueSolarMillisSinceEpoch - startMillis, dayMillis) / dayMillis);
	    var yearPhaseSinceNorthSummerSolstice = getYearPhaseSinceNorthSummerSolstice(trueSolarMillisSinceEpoch);
	    return getZenithInDegrees(yearPhaseSinceNorthSummerSolstice, toRadians(axialTilt), toRadians(latitude), toRadians(longitude + dayPhase));
	}

	function getZenithInDegrees(yearPhaseSinceNorthSummerSolstice, axialTilt, latitude, angleOffset) {
	    var sinYearPhase = Math.sin(yearPhaseSinceNorthSummerSolstice);
	    var cosYearPhase = Math.cos(yearPhaseSinceNorthSummerSolstice);
	    var cosYearPhaseMultipleCosAxialTilt = cosYearPhase * Math.cos(axialTilt);
	    var cosZenith = Math.sin(latitude) * Math.sin(axialTilt) * cosYearPhase +
		Math.cos(latitude) * Math.cos(angleOffset) *
		    Math.sqrt(cosYearPhaseMultipleCosAxialTilt * cosYearPhaseMultipleCosAxialTilt + sinYearPhase * sinYearPhase);
	    return toDegrees(Math.acos(cosZenith));
	}

	function mod(a, b) {
	    var m = a % b;

	    if (m < 0) {
		return b + m;
	    }

	    return m;
	}

	function pad_radix(num, count, radix) {
	    var str = num.toString(radix);

	    while (str.length < count) {
		str = "0" + str;
	    }

	    return str;
	}

	function pad(num, count) {
	    return pad_radix(num, count, 10);
	}

	function pad2(num) {
	    return pad_radix(num, 2, 16);
	}

	function getDurationSec(begin, end) {
	    return Math.floor((end - begin) / 1000);
	}

	function getPeriod(durationSec) {
	    var sec = durationSec % 60;
	    durationSec = Math.floor(durationSec / 60);
	    var min = durationSec % 60;
	    durationSec = Math.floor(durationSec / 60);
	    var hour = durationSec % 24;
	    durationSec = Math.floor(durationSec / 24);
	    var days = durationSec;

	    return { sec: sec, min: min, hour: hour, days: days };
	}

	function formatPeriod(period) {
	    return period.days + "." + pad(period.hour,2) + ":" + pad(period.min,2) + ":" + pad(period.sec,2);
	}

	function RGB(red, green, blue) {
	    this.red = red;
	    this.green = green;
	    this.blue = blue;
	}

	function ColorTuple(bgColor, color) {
	    this.bgColor = bgColor;
	    this.color = color;
	}

	function ColorTupleSet(low, medium, high, unnamed) {
	    this.low = low;
	    this.medium = medium;
	    this.high = high;
	    this.unnamed = unnamed;
	}

	function ColorTuplePair(left, right) {
	    this.left = left;
	    this.right = right;
	}

	function colorToStyle(color) {
	    return '#' + pad2(color.red) + pad2(color.green) + pad2(color.blue);
	}

	function colorTupleToStyle(colorTuple) {
	    return 'background-color: ' + colorToStyle(colorTuple.bgColor) + '; ' + 'color: ' + colorToStyle(colorTuple.color) + ';';
	}

	function getPart(a, b, part) {
	    return Math.round(a + (b-a)*part);
	}

	function getColorPart(aColor, bColor, part) {
	    return new RGB(
		getPart(aColor.red, bColor.red, part),
		getPart(aColor.green, bColor.green, part),
		getPart(aColor.blue, bColor.blue, part),
	    );
	}

	function getColorTuplePart(aColorTuple, bColorTuple, part) {
	    return new ColorTuple(
		getColorPart(aColorTuple.bgColor, bColorTuple.bgColor, part),
		getColorPart(aColorTuple.color, bColorTuple.color, part),
	    );
	}

	function getColorTuple(colorTupleSet, total, bestTotal) {
	    if (total <= 0) {
		return colorTupleSet.low;
	    }

	    if (total >= bestTotal) {
		return colorTupleSet.high;
	    }

	    var halfBestTotal = bestTotal / 2;

	    var pair = total < halfBestTotal ? new ColorTuplePair(colorTupleSet.low, colorTupleSet.medium) : new ColorTuplePair(colorTupleSet.medium, colorTupleSet.high);

	    var newTotal = total < halfBestTotal ? total : total - halfBestTotal;

	    return getColorTuplePart(pair.left, pair.right, newTotal / halfBestTotal);
	}

	function update() {
	    var lastIncidentDateValue = lastIncidentDate;
	    var bestPeriodBeginValue = bestPeriodBegin;
	    var bestPeriodEndValue = bestPeriodEnd;

	    var night = new ColorTupleSet(
		new ColorTuple(new RGB(0x3b, 0x17, 0x17), new RGB(0xc8, 0x2e, 0x2e)),
		new ColorTuple(new RGB(0x3b, 0x3b, 0x17), new RGB(0xc8, 0xc8, 0x2e)),
		new ColorTuple(new RGB(0x17, 0x3b, 0x17), new RGB(0x2e, 0xc8, 0x2e)),
		new ColorTuple(new RGB(0x17, 0x17, 0x3b), new RGB(0x2e, 0x2e, 0xc8))
	    );

	    var day = new ColorTupleSet(
		new ColorTuple(new RGB(0xff, 0xe0, 0xe0), new RGB(0xcc, 0x00, 0x00)),
		new ColorTuple(new RGB(0xef, 0xef, 0xe0), new RGB(0xcc, 0x99, 0x00)),
		new ColorTuple(new RGB(0xe0, 0xff, 0xe0), new RGB(0x33, 0x66, 0x00)),
		new ColorTuple(new RGB(0xe0, 0xe0, 0xff), new RGB(0x00, 0x00, 0x66))
	    );

	    var now = new Date(Date.now());
	    var foolDay = foolDayOn && now.getDate() == 1 && now.getMonth() == 3;
	    var newYearIsComing = newYearOn && now.getDate() > 15 && now.getMonth() == 11;
	    if (newYearIsComing) {
		lastIncidentDateValue = now;
		bestPeriodBeginValue = new Date('0004-01-01T00:00:00')
		bestPeriodEndValue = new Date('0005-01-01T00:00:00');
	    }
	    var bestPeriodDuration = getDurationSec(bestPeriodBeginValue, bestPeriodEndValue);
	    var totalDurationSec = newYearIsComing ? getDurationSec(now, new Date(now.getFullYear() + 1, 0, 1, 0, 0, 0, 0)) : getDurationSec(lastIncidentDateValue, now);
	    var total = foolDay ? 100000 * 24 * 60 * 60 - totalDurationSec : totalDurationSec;
	    var period = getPeriod(total);
	    var periodStr = formatPeriod(period);
	    var timeElement = document.getElementById("time");
	    timeElement.innerText = periodStr;
	    var daysElement = document.getElementById("days");
	    daysElement.innerText = pad(period.days,5);
	    var bestElement = document.getElementById("achieved");
	    var durationElement = document.getElementById("duration");
	    bestElement.innerText = total < bestPeriodDuration ? bestPeriodEndValue : now;
	    durationElement.innerText = total < bestPeriodDuration ? formatPeriod(getPeriod(bestPeriodDuration)) : periodStr;
	    var colorTupleSet = isDay(now, latitude, longitude) ^ foolDay ? day : night;
	    var bodyElement = document.getElementById("body");
	    var colorTuple;
	    if (newYearIsComing) {
		var seconds = now.getSeconds() % 10;
		var pseudoTotal = seconds < 5 ? seconds * 1000 + now.getMilliseconds() : 5000 - (seconds - 5) * 1000 - now.getMilliseconds();
		colorTuple = getColorTuple(colorTupleSet, pseudoTotal, 5000);
	    } else {
		colorTuple = getColorTuple(colorTupleSet, total, bestPeriodDuration);
	    }
	    bodyElement.setAttribute("style", colorTupleToStyle(colorTuple));
	    var daysNotice = document.getElementById("days-notice");
	    daysNotice.innerText = newYearIsComing ? "days till the next year" : "days since last incident";
	    var timeNotice = document.getElementById("time-notice");
	    timeNotice.innerText = newYearIsComing ? "till the next year" : "since last incident";
	}
	update();
	setInterval(update, 100);
   </script>
</html>

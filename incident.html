<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>
         Time since last incident
      </title>
      <style>
	.notice {
	    text-align: center;
	    vertical-align: middle;
	    margin-left: auto;
	    margin-right: auto;
	    margin-bottom: 50px;
	    margin-top: auto;
	    font-size: 50pt;
	}

	.time {
	    text-align: center;
	    vertical-align: middle;
	    margin: auto;
	    font-size: 50pt;
	}

	.best-notice {
	    text-align: center;
	    vertical-align: middle;
	    margin-left: auto;
	    margin-right: auto;
	    margin-bottom: auto;
	    margin-top: 100px;
	    font-size: 20pt;
	}

	.days {
	    text-align: center;
	    vertical-align: middle;
	    margin: auto;
	    font-size: 350pt;
	    height: 500px;
	}
      </style>
   </head>
   <body id="body">
	<div id="days" class="days">00000</div>
	<div class="notice" id="days-notice">days since last incident</div>
	<div id="time" class="time">0.00:00:00</div>
	<div class="notice" id="time-notice">since last incident</div>
	<div class="best-notice">the best duration <span id="duration">&lt;none&gt;</span> achieved at <span id="achieved">&lt;never&gt;</span></div>
   </body>
   <script>
	// Zenith day threshold values:
	// * Include day time only: 90 + 50.0 / 60.0
	// * Include civil twilight: 96
	// * Include nautical twilight: 102
	// * Include astronomical twilight: 108
	const zenithDayThresholdDegrees = 90 + 50.0 / 60.0;

	const axialTilt = 23.4392811;
	const tropicalYearMillis = 31556925190;
	const dayMillis = 86400000;
	const millisInMinute = 60000;

	function toRadians(degrees) {
	    return degrees * Math.PI / 180.0;
	}

	function toDegrees(radians) {
	    return radians * 180.0 / Math.PI;
	}

	function toSectorDegree(part) {
	    return 360.0 * part;
	}

	function isDay(date, latitude, longitude) {
	    return getCorrectedZenithInDegrees(date, latitude, longitude) < zenithDayThresholdDegrees;
	}

	function getTrueSolarMillisSinceEpoch(date) {
	    var millisSinceEpoch = date.getTime();
	    var phaseStartMillis = new Date('2019-01-01T00:00:00Z').getTime();
	    var yearPhase = toRadians(toSectorDegree(mod(millisSinceEpoch - phaseStartMillis, tropicalYearMillis) / tropicalYearMillis));
	    var equationOfTimeMillis = (-7.659 * Math.sin(yearPhase) + 9.863 * Math.sin(2 * yearPhase + 3.5932)) * millisInMinute;
	    return millisSinceEpoch + equationOfTimeMillis;
	}

	function getYearPhaseSinceNorthSummerSolstice(millisSinceEpoch) {
	    var northSummerSolsticeMillis = new Date('2019-06-21T15:54:14Z').getTime();
	    return toRadians(toSectorDegree(mod(millisSinceEpoch - northSummerSolsticeMillis, tropicalYearMillis) / tropicalYearMillis));
	}

	function getCorrectedZenithInDegrees(date, latitude, longitude) {
	    var trueSolarMillisSinceEpoch = getTrueSolarMillisSinceEpoch(date);
	    var startMillis = new Date('2019-12-26T12:00:00Z').getTime();
	    var dayPhase = toSectorDegree(mod(trueSolarMillisSinceEpoch - startMillis, dayMillis) / dayMillis);
	    var yearPhaseSinceNorthSummerSolstice = getYearPhaseSinceNorthSummerSolstice(trueSolarMillisSinceEpoch);
	    return getZenithInDegrees(yearPhaseSinceNorthSummerSolstice, toRadians(axialTilt), toRadians(latitude), toRadians(longitude + dayPhase));
	}

	function getZenithInDegrees(yearPhaseSinceNorthSummerSolstice, axialTilt, latitude, angleOffset) {
	    var sinYearPhase = Math.sin(yearPhaseSinceNorthSummerSolstice);
	    var cosYearPhase = Math.cos(yearPhaseSinceNorthSummerSolstice);
	    var cosYearPhaseMultipleCosAxialTilt = cosYearPhase * Math.cos(axialTilt);
	    var cosZenith = Math.sin(latitude) * Math.sin(axialTilt) * cosYearPhase +
		Math.cos(latitude) * Math.cos(angleOffset) *
		    Math.sqrt(cosYearPhaseMultipleCosAxialTilt * cosYearPhaseMultipleCosAxialTilt + sinYearPhase * sinYearPhase);
	    return toDegrees(Math.acos(cosZenith));
	}

	function mod(a, b) {
	    var m = a % b;

	    if (m < 0) {
		return b + m;
	    }

	    return m;
	}

	function pad_radix(num, count, radix) {
	    var str = num.toString(radix);

	    while (str.length < count) {
		str = "0" + str;
	    }

	    return str;
	}

	function pad(num, count) {
	    return pad_radix(num, count, 10);
	}

	function pad2(num) {
	    return pad_radix(num, 2, 16);
	}

	function getDurationSec(begin, end) {
	    return Math.floor((end - begin) / 1000);
	}

	function getPeriod(durationSec) {
	    var sec = durationSec % 60;
	    durationSec = Math.floor(durationSec / 60);
	    var min = durationSec % 60;
	    durationSec = Math.floor(durationSec / 60);
	    var hour = durationSec % 24;
	    durationSec = Math.floor(durationSec / 24);
	    var days = durationSec;

	    return { sec: sec, min: min, hour: hour, days: days };
	}

	function formatPeriod(period) {
	    return period.days + "." + pad(period.hour,2) + ":" + pad(period.min,2) + ":" + pad(period.sec,2);
	}

	function RGB(red, green, blue) {
	    this.red = red;
	    this.green = green;
	    this.blue = blue;
	}

	function ColorTuple(bg_color, color) {
	    this.bg_color = bg_color;
	    this.color = color;
	}

	function ColorTupleSet(low, medium, high, unnamed) {
	    this.low = low;
	    this.medium = medium;
	    this.high = high;
	    this.unnamed = unnamed;
	}

	function ColorTuplePair(left, right) {
	    this.left = left;
	    this.right = right;
	}

	function colorToStyle(color) {
	    return '#' + pad2(color.red) + pad2(color.green) + pad2(color.blue);
	}

	function colorTupleToStyle(color_tuple) {
	    return 'background-color: ' + colorToStyle(color_tuple.bg_color) + '; ' + 'color: ' + colorToStyle(color_tuple.color) + ';';
	}

	function getPart(a, b, part) {
	    return Math.round(a + (b-a)*part);
	}

	function getColorPart(a_color, b_color, part) {
	    return new RGB(
		getPart(a_color.red, b_color.red, part),
		getPart(a_color.green, b_color.green, part),
		getPart(a_color.blue, b_color.blue, part),
	    );
	}

	function getColorTuplePart(a_color_tuple, b_color_tuple, part) {
	    return new ColorTuple(
		getColorPart(a_color_tuple.bg_color, b_color_tuple.bg_color, part),
		getColorPart(a_color_tuple.color, b_color_tuple.color, part),
	    );
	}

	function getColorTuple(color_tuple_set, total, best_total) {
	    if (total <= 0) {
		return color_tuple_set.low;
	    }

	    if (total >= best_total) {
		return color_tuple_set.high;
	    }

	    var half_best_total = best_total / 2;

	    var pair = total < half_best_total ? new ColorTuplePair(color_tuple_set.low, color_tuple_set.medium) : new ColorTuplePair(color_tuple_set.medium, color_tuple_set.high);

	    var new_total = total < half_best_total ? total : total - half_best_total;

	    return getColorTuplePart(pair.left, pair.right, new_total / half_best_total);
	}

	function update() {
	    var last_incident_day = new Date('2018-09-10T19:00:00'); // MSK
	    var best_period_begin = new Date('2018-01-25T13:54:00'); // MSK
	    var best_period_end = new Date('2018-02-27T23:00:00'); // MSK

	    var latitude = 59.9586496; // Spb latitude
	    var longitude = 30.4066436; // Spb longitude

	    var night = new ColorTupleSet(
		new ColorTuple(new RGB(0x3b, 0x17, 0x17), new RGB(0xc8, 0x2e, 0x2e)),
		new ColorTuple(new RGB(0x3b, 0x3b, 0x17), new RGB(0xc8, 0xc8, 0x2e)),
		new ColorTuple(new RGB(0x17, 0x3b, 0x17), new RGB(0x2e, 0xc8, 0x2e)),
		new ColorTuple(new RGB(0x17, 0x17, 0x3b), new RGB(0x2e, 0x2e, 0xc8))
	    );

	    var day = new ColorTupleSet(
		new ColorTuple(new RGB(0xff, 0xe0, 0xe0), new RGB(0xcc, 0x00, 0x00)),
		new ColorTuple(new RGB(0xef, 0xef, 0xe0), new RGB(0xcc, 0x99, 0x00)),
		new ColorTuple(new RGB(0xe0, 0xff, 0xe0), new RGB(0x33, 0x66, 0x00)),
		new ColorTuple(new RGB(0xe0, 0xe0, 0xff), new RGB(0x00, 0x00, 0x66))
	    );

	    var now = new Date(Date.now());
	    var foolDay = now.getDate() == 1 && now.getMonth() == 3;
	    var newYearIsComing = now.getDate() > 15 && now.getMonth() == 11;
	    if (newYearIsComing) {
		last_incident_day = now;
		best_period_begin = new Date('0004-01-01T00:00:00')
		best_period_end = new Date('0005-01-01T00:00:00');
	    }
	    var best_period_duration = getDurationSec(best_period_begin, best_period_end);
	    var totalDurationSec = newYearIsComing ? getDurationSec(now, new Date(now.getFullYear() + 1, 0, 1, 0, 0, 0, 0)) : getDurationSec(last_incident_day, now);
	    var total = foolDay ? 100000 * 24 * 60 * 60 - totalDurationSec : totalDurationSec;
	    var period = getPeriod(total);
	    var periodStr = formatPeriod(period);
	    var timeElement = document.getElementById("time");
	    timeElement.innerText = periodStr;
	    var daysElement = document.getElementById("days");
	    daysElement.innerText = pad(period.days,5);
	    var bestElement = document.getElementById("achieved");
	    var durationElement = document.getElementById("duration");
	    bestElement.innerText = total < best_period_duration ? best_period_end : now;
	    durationElement.innerText = total < best_period_duration ? formatPeriod(getPeriod(best_period_duration)) : periodStr;
	    var colorTupleSet = isDay(now, latitude, longitude) ^ foolDay ? day : night;
	    var bodyElement = document.getElementById("body");
	    var colorTuple;
	    if (newYearIsComing) {
		var seconds = now.getSeconds() % 10;
		var pseudo_total = seconds < 5 ? seconds * 1000 + now.getMilliseconds() : 5000 - (seconds - 5) * 1000 - now.getMilliseconds();
		colorTuple = getColorTuple(colorTupleSet, pseudo_total, 5000);
	    } else {
		colorTuple = getColorTuple(colorTupleSet, total, best_period_duration);
	    }
	    bodyElement.setAttribute("style", colorTupleToStyle(colorTuple));
	    var daysNotice = document.getElementById("days-notice");
	    daysNotice.innerText = newYearIsComing ? "days till the next year" : "days since last incident";
	    var timeNotice = document.getElementById("time-notice");
	    timeNotice.innerText = newYearIsComing ? "till the next year" : "since last incident";
	}
	update();
	setInterval(update, 100);
   </script>
</html>
